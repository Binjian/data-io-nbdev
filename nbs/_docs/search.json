[
  {
    "objectID": "00_core.html#show-a-graph-with-mermaid",
    "href": "00_core.html#show-a-graph-with-mermaid",
    "title": "core",
    "section": "show a graph with mermaid",
    "text": "show a graph with mermaid\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nrun\n\n run   \n\nintr\n\n intr   \n\nrun–intr\n\n   \n\nkernel\n\n kernel   \n\nrun–kernel\n\n   \n\nrunbl\n\n runbl   \n\nintr–runbl\n\n   \n\nrunbl–run\n\n   \n\nzombie\n\n zombie   \n\nkernel–zombie\n\n   \n\nsleep\n\n sleep   \n\nkernel–sleep\n\n   \n\nrunmem\n\n runmem   \n\nkernel–runmem\n\n   \n\nsleep–runmem\n\n   \n\nswap\n\n swap   \n\nsleep–swap\n\n   \n\nrunswap\n\n runswap   \n\nswap–runswap\n\n   \n\nrunswap–runmem\n\n   \n\nnew\n\n new   \n\nrunswap–new\n\n   \n\nnew–runmem\n\n  \n\n\n\n\n\n\n\n\n\nsequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n    John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br/&gt;prevail!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!"
  },
  {
    "objectID": "99_sandbox.html#show-a-graph-with-mermaid",
    "href": "99_sandbox.html#show-a-graph-with-mermaid",
    "title": "sandbox",
    "section": "show a graph with mermaid",
    "text": "show a graph with mermaid\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nrun\n\n run   \n\nintr\n\n intr   \n\nrun–intr\n\n   \n\nkernel\n\n kernel   \n\nrun–kernel\n\n   \n\nrunbl\n\n runbl   \n\nintr–runbl\n\n   \n\nrunbl–run\n\n   \n\nzombie\n\n zombie   \n\nkernel–zombie\n\n   \n\nsleep\n\n sleep   \n\nkernel–sleep\n\n   \n\nrunmem\n\n runmem   \n\nkernel–runmem\n\n   \n\nsleep–runmem\n\n   \n\nswap\n\n swap   \n\nsleep–swap\n\n   \n\nrunswap\n\n runswap   \n\nswap–runswap\n\n   \n\nrunswap–runmem\n\n   \n\nnew\n\n new   \n\nrunswap–new\n\n   \n\nnew–runmem\n\n  \n\n\n\n\n\n\n\n\n\nsequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n    John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br/&gt;prevail!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!"
  },
  {
    "objectID": "99_sandbox.html#add-a-class",
    "href": "99_sandbox.html#add-a-class",
    "title": "sandbox",
    "section": "add a class",
    "text": "add a class\n\n\nHelloSayer\n\n HelloSayer (to)\n\nSay hello to to using say_hello\n\n\n\nHelloSayer.say\n\n HelloSayer.say ()\n\n\no = HelloSayer(\"Alexis\")\no.say()\n\n'Hello Alexis!'"
  },
  {
    "objectID": "99_sandbox.html#add-math",
    "href": "99_sandbox.html#add-math",
    "title": "sandbox",
    "section": "add math",
    "text": "add math\n\\[\\sum_{i=1}^{k+1}i\\]"
  },
  {
    "objectID": "01.data.time.html",
    "href": "01.data.time.html",
    "title": "data time",
    "section": "",
    "text": "from zoneinfo import ZoneInfo"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "data_io_nbdev",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "data_io_nbdev",
    "section": "Install",
    "text": "Install\npip install data_io_nbdev"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "data_io_nbdev",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "01.data.eos.html",
    "href": "01.data.eos.html",
    "title": "data eos",
    "section": "",
    "text": "from __future__ import annotations\n\n\nimport re\nfrom configparser import ConfigParser\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, NamedTuple, Optional, Tuple, TypeVar, Union, TypeAlias\nfrom zoneinfo import ZoneInfo  # type: ignore\n\n\nimport pandas as pd  # type: ignore\nfrom pydantic import BaseModel, Field, GetPydanticSchema  # type: ignore\nfrom pydantic.dataclasses import dataclass  # type: ignore\nfrom typing_extensions import TypedDict\n\n\nfrom eos.data_io.eos_struct.eos_location import EosLocation\n#  Define TypedDict for type hinting of typed collections: records and episodes\nveos_lifetime_start_date: pd.Timestamp = pd.Timestamp(\n    ts_input=\"2021-01-01T00:00:00+08:00\", tz=\"Asia/Shanghai\"\n)\nveos_lifetime_end_date: pd.Timestamp = pd.Timestamp(\n    ts_input=\"2031-12-31T00:00:00+08:00\", tz=\"Asia/Shanghai\"\n)\n\n\nKvaserType: TypeAlias = dict[str, str]\nRCANType: TypeAlias = dict[str, dict[str, list[Union[str, list[list[str]]]]]]\n# RawType: TypeAlias = dict[str, Union[str, dict[str, list[Union[str, list[str]]]]]]\nRawType: TypeAlias = Union[KvaserType, RCANType]\n\n\nclass MotionPower(NamedTuple):\n    timestep: pd.Timestamp\n    velocity: float\n    thrust: float\n    brake: float\n    current: float\n    voltage: float\n\n\nclass ECUMixin(BaseModel):\n    # optional: can be adjusted by developer\n    ecu_observation_number: int = 30\n    #     (KvaserMixin.kvaser_observation_number\n    # )  # 30  # Kvaser number of one observation unit: 30 as count number\n    ecu_observation_frequency: int = 20\n    #     (KvaserMixin.kvaser_observation_frequency\n    #     # 20  # Kvaser observation frequency: 20 Hz, fixed by hardware setting\n    # )\n    ecu_countdown: int = 3\n    #     (KvaserMixin.kvaser_countdown\n    #     # 3  # Kvaser countdown time: 3 seconds, optional: can be adjusted by developer\n    # )\n\n\nclass CloudMixin(BaseModel):\n    \"\"\"\n    fixed by hardware setting of remotecan\n    \"\"\"\n\n    cloud_signal_frequency: int = 50  # TboxMixin.tbox_signal_frequency  # 50  # Hz\n    cloud_gear_frequency: int = 2  # TboxMixin.tbox_gear_frequency  # 2  # Hz\n    cloud_unit_duration: int = 1\n    #     (TboxMixin.tbox_unit_duration\n    # )  # 1  # cloud unit duration in seconds\n    cloud_unit_number: int = 4\n    #     (TboxMixin.tbox_unit_number\n    # )  # int = 4  # cloud number of units of cloud observation\n\n\nclass StateUnitCodes(BaseModel):\n    \"\"\"Observation of the episode.\"\"\"\n\n    velocity_unit_code: str = \"kph\"  # unit of velocity, default \"kph\"\n    thrust_unit_code: str = \"pct\"  # unit of thrust, default \"pct\"\n    brake_unit_code: str = \"pct\"  # unit of brake, default \"pct\"\n\n\n@dataclass(kw_only=True)\nclass StateSpecs:\n    \"\"\"Observation of the episode.\"\"\"\n\n    state_unit_codes: StateUnitCodes = Field(default_factory=StateUnitCodes)\n    state_number: int = 3  # number of states, default 3, velocity, thrust, brake\n    unit_number_per_state: int = 200  # number of units, default 4\n    unit_duration: float = 1.0  # duration of each unit, default 1 second\n    frequency: int = 50  # frequency of each unit, default 50 Hz\n\n\n@dataclass\nclass StateSpecsCloud(StateSpecs):\n    \"\"\"\n    StateSpecs for cloud interface\n    \"\"\"\n\n    cloud_interface: CloudMixin = Field(default_factory=CloudMixin)\n\n    def __post_init__(self):\n        self.state_number = 3\n        self.unit_number_per_state = int(\n            self.cloud_interface.cloud_unit_number\n            * self.cloud_interface.cloud_unit_duration\n            * self.cloud_interface.cloud_signal_frequency\n        )  # 4*1*50 = 200\n        self.unit_duration = (\n            self.cloud_interface.cloud_unit_duration\n            * self.cloud_interface.cloud_unit_number\n        )  # 1.0 * 4 = 4.0s\n        self.frequency = self.cloud_interface.cloud_signal_frequency  # 50\n\n\n@dataclass\nclass StateSpecsECU(StateSpecs):\n    \"\"\"\n    StateSpecs for Kvaser interface\n    \"\"\"\n\n    ecu_interface: ECUMixin = Field(default_factory=ECUMixin)\n\n    def __post_init__(self):\n        self.state_number = 3\n        self.unit_number_per_state = self.ecu_interface.ecu_observation_number  # 30\n        self.unit_duration = (\n            self.ecu_interface.ecu_observation_number\n            / self.ecu_interface.ecu_observation_frequency  # 1.5s\n        )\n        self.frequency = self.ecu_interface.ecu_observation_frequency  # 20\n\n\nclass ActionSpecs(BaseModel):\n    \"\"\"Action of the episode.\"\"\"\n\n    action_unit_code: str = \"nm\"  # unit of action, default \"nm\"\n    action_row_number: int = 4  # trucks_by_id[\"default\"].torque_table_row_num_flash  # 4  # number of rows, default 4\n    action_column_number: int = 17  # trucks_by_id[\"default\"].torque_table_col_num  # 17  # number of columns, default 17 len(PEDAL_SCALE)\n\n\nclass RewardSpecs(BaseModel):\n    \"\"\"Reward of the episode.\"\"\"\n\n    reward_unit_code: str = \"wh\"  # unit of reward, default \"wh\"\n    reward_number: int = 1  # number of rewards, default 1, current reward, can be extended to multiple past rewards\n\n\nclass ObservationMeta(BaseModel):\n    \"\"\"\n    selected metadata for db document matching pandas DataFrame\n    \"\"\"\n\n    state_specs: StateSpecs  # StateSpecs()\n    # ActionSpecs(action_unit_code=\"nm\",\n    #             action_row_number=trucks_by_id[\"default\"].torque_table_row_num_flash,  # 4\n    #             action_column_number=trucks_by_id[\"default\"].torque_table_col_num,  # 17)\n    action_specs: ActionSpecs\n    reward_specs: RewardSpecs  # RewardSpecs(reward_unit_code=\"wh\")\n    site: EosLocation  # \"at\"  # observation (testing) site\n\n    def get_number_of_states(self) -&gt; int:\n        \"\"\"\n        get number of states from StateSpecs\n        \"\"\"\n\n        return self.state_specs.state_number * self.state_specs.unit_number_per_state\n\n    def get_number_of_actions(self) -&gt; int:\n        \"\"\"\n        get number of actions from ActionSpecs\n        \"\"\"\n        return (\n            self.action_specs.action_row_number * self.action_specs.action_column_number\n        )\n\n    def get_number_of_states_actions(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        get number of states and actions from Plot\n        \"\"\"\n        return self.get_number_of_states(), self.get_number_of_actions()\n\n    def have_same_meta(self, meta_to_compare: ObservationMeta):\n        \"\"\"\n        Compare two plots, return True if they are the same, while ignoring the 'when' field\n        \"\"\"\n        return all(\n            [\n                all([\n                    self.state_specs.state_unit_codes == meta_to_compare.state_specs.state_unit_codes,\n                    self.state_specs.state_number == meta_to_compare.state_specs.state_number,\n                    self.state_specs.unit_number_per_state == meta_to_compare.state_specs.unit_number_per_state,\n                    self.state_specs.unit_duration == meta_to_compare.state_specs.unit_duration,\n                    self.state_specs.frequency == meta_to_compare.state_specs.frequency\n                ]),\n                all([self.action_specs.action_row_number == meta_to_compare.action_specs.action_row_number,\n                     self.action_specs.action_column_number == meta_to_compare.action_specs.action_column_number,\n                     self.action_specs.action_unit_code == meta_to_compare.action_specs.action_unit_code\n                ]),\n                self.reward_specs == meta_to_compare.reward_specs,\n                self.site == meta_to_compare.site,\n            ]\n        )\n        # return all(\n        #     [\n        #         getattr(self, attr) == getattr(meta_to_compare, attr)\n        #         for attr in list(self.__slots__)\n        #     ]\n        # )\n\n    def get_torque_table_row_names(self) -&gt; List[str]:\n        \"\"\"\n        get torque table row names from reward_specs\n        defined as [r0, r1, r2, ...]\n        \"\"\"\n        torque_table_row_names = [\n            f\"r{i}\" for i in range(self.action_specs.action_row_number)\n        ]\n        return torque_table_row_names\n\n\n# @dataclass(slots=True)  # use slot to save memory and fix the attributes\nclass ObservationMetaCloud(ObservationMeta):\n    \"\"\"\n    selected metadata for db document matching pandas DataFrame\n    \"\"\"\n\n    state_specs: StateSpecsCloud  # Field(default_factory=StateSpecs)\n\n\n# @dataclass(slots=True)  # use slot to save memory and fix the attributes\nclass ObservationMetaECU(ObservationMeta):\n    \"\"\"\n    selected metadata for db document matching pandas DataFrame\n    \"\"\"\n\n    state_specs: StateSpecsECU  # Field(default_factory=StateSpecsECU)\n\n\nclass DataFrameDoc(TypedDict):\n    \"\"\"Record doc type of mongo pool for record\"\"\"\n\n    timestamp: datetime  # only usage of Datetime type, as interface to MongoDB timestamp (BSON Date)\n    meta: dict\n    observation: dict\n    # for RECORD seq_len = 1\n\nItemT = TypeVar(“ItemT”, bound=TypedDict)\n\nItemT = TypeVar(\"ItemT\", Dict, pd.DataFrame)\n\n\nclass PoolQuery(BaseModel):\n    \"\"\"Query for Record\"\"\"\n\n    vehicle: str  # \"\"\n    driver: str  # \"\"\n    episodestart_start: datetime = (\n        veos_lifetime_start_date.to_pydatetime()\n    )  # timezone aware\n    episodestart_end: datetime = (\n        veos_lifetime_end_date.to_pydatetime()\n    )  # timezone aware\n    timestamp_start: Optional[datetime] = None  # for episode query should be None\n    timestamp_end: Optional[datetime] = None  # for episode query should be None\n    seq_len_from: Optional[\n        int\n    ] = None  # default for record query, for episode query should be sequence length, default to around 200, like 160\n    seq_len_to: Optional[\n        int\n    ] = None  # default for record query, for episode query should be &gt; 200, like 240\n\n\nRE_RECIPEKEY = re.compile(r\"^[A-Za-z]\\w*\\.ini$\")\n\n\ndef get_filemeta_config(\n    data_folder: str,\n    config_file: Optional[str],\n    meta: Union[ObservationMetaCloud, ObservationMetaECU],\n    coll_type: str,\n) -&gt; ConfigParser:\n    \"\"\"Get the filepool config from the specified path data_folder + '\\' + config_file\n        and compare the meat data with the plot info\n    Returns:\n        ConfigParser: filepool config\n    \"\"\"\n\n    recipe_default: ConfigParser = ConfigParser()\n    number_states, number_actions = meta.get_number_of_states_actions()\n    recipe_default.read_dict(\n        {\n            \"DEFAULT\": {  # should go into parquet tabel meta info\n                \"data_folder\": data_folder,  # '.',\n                \"recipe_file_name\": \"\",  # 'recipe.ini',\n                \"coll_type\": coll_type,\n            },\n            \"array_specs\": {  # should go into parquet columns meta info\n                \"states\": str(number_states),  # 50*4*3\n                \"actions\": str(number_actions),  # 17*4\n                \"rewards\": \"1\",\n                \"next_states\": str(number_states),  # 50*4*3\n            },\n        }\n    )\n\n    recipe: ConfigParser = ConfigParser()\n    if config_file is None:\n        recipe_default[\"DEFAULT\"][\"recipe_file_name\"] = \"recipe.ini\"\n    else:\n        recipe_p = re.compile(RE_RECIPEKEY)\n        assert recipe_p.match(\n            config_file\n        ), f\"recipe file name {config_file} is not valid\"\n        recipe_default[\"DEFAULT\"][\"recipe_file_name\"] = config_file\n        data_folder_path = Path(data_folder)\n        config_file_path = data_folder_path / config_file\n        try:\n            recipe.read_file(open(config_file_path))\n            # check if the recipe is matching with the truck specs\n            # assert (\n            #     recipe['array_specs'] == recipe_default['array_specs']\n            # ), f\"ini file array_specs is not matching the realtime truck signal specs\"\n        except FileNotFoundError:\n            recipe = recipe_default\n            data_folder_path.mkdir(parents=True, exist_ok=True)\n            with open(config_file_path, \"w\") as configfile:\n                recipe.write(configfile)\n        except Exception as e:\n            raise Exception(f\"Error reading recipe file {config_file_path}, {e}\")\n        recipe['DEFAULT']['coll_type'] = coll_type\n\n    return recipe"
  },
  {
    "objectID": "01.data.location.html",
    "href": "01.data.location.html",
    "title": "data location",
    "section": "",
    "text": "source\n\nEosLocation\n\n EosLocation (abbr:str, name:str, cname:str, tz:zoneinfo.ZoneInfo)\n\nusage docs: https://docs.pydantic.dev/2.0/usage/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of classvars defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The signature for instantiating the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a `RootModel`.\n__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n__pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n__pydantic_extra__: An instance attribute with the values of extra fields from validation when\n    `model_config['extra'] == 'allow'`.\n__pydantic_fields_set__: An instance attribute with the names of fields explicitly specified during validation.\n__pydantic_private__: Instance attribute with the values of private attributes set on the model instance."
  },
  {
    "objectID": "01.data.time.html#timezone",
    "href": "01.data.time.html#timezone",
    "title": "data time",
    "section": "",
    "text": "from zoneinfo import ZoneInfo"
  },
  {
    "objectID": "02_numerics.html#show-a-graph-with-mermaid",
    "href": "02_numerics.html#show-a-graph-with-mermaid",
    "title": "numerics",
    "section": "show a graph with mermaid",
    "text": "show a graph with mermaid\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nrun\n\n run   \n\nintr\n\n intr   \n\nrun–intr\n\n   \n\nkernel\n\n kernel   \n\nrun–kernel\n\n   \n\nrunbl\n\n runbl   \n\nintr–runbl\n\n   \n\nrunbl–run\n\n   \n\nzombie\n\n zombie   \n\nkernel–zombie\n\n   \n\nsleep\n\n sleep   \n\nkernel–sleep\n\n   \n\nrunmem\n\n runmem   \n\nkernel–runmem\n\n   \n\nsleep–runmem\n\n   \n\nswap\n\n swap   \n\nsleep–swap\n\n   \n\nrunswap\n\n runswap   \n\nswap–runswap\n\n   \n\nrunswap–runmem\n\n   \n\nnew\n\n new   \n\nrunswap–new\n\n   \n\nnew–runmem\n\n  \n\n\n\n\n\n\n\n\n\nsequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n    John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br/&gt;prevail!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!"
  },
  {
    "objectID": "02_numerics.html",
    "href": "02_numerics.html",
    "title": "numerics",
    "section": "",
    "text": "source\n\nassemble_state_ser\n\n assemble_state_ser (state_columns:pandas.core.frame.DataFrame,\n                     tz:zoneinfo.ZoneInfo)\n\nassemble state df from state_columns dataframe order is vital for the model: “timestep, velocity, thrust, brake” contiguous storage in each measurement due to sort_index, output: [col0: brake, col1: thrust, col2: timestep, col3: velocity] return: state: pd.Series table_row_start: int\n\nassert assemble_state_ser(state, tz)[1] == 0\n\n\nassert isinstance(assemble_state_ser(state, tz)[0], pd.Series) == True\n\n\nfrom fastcore.test import *\n\n\ntest_eq(isinstance(assemble_state_ser(state, tz)[0], pd.Series), True)"
  },
  {
    "objectID": "98_utils.html",
    "href": "98_utils.html",
    "title": "utils",
    "section": "",
    "text": "source\n\n\n\n generate_state ()\n\ngenerate a pandas DataFrame for testing purpose"
  },
  {
    "objectID": "98_utils.html#generate-state",
    "href": "98_utils.html#generate-state",
    "title": "utils",
    "section": "",
    "text": "source\n\n\n\n generate_state ()\n\ngenerate a pandas DataFrame for testing purpose"
  },
  {
    "objectID": "98_utils.html#generate-action",
    "href": "98_utils.html#generate-action",
    "title": "utils",
    "section": "Generate action",
    "text": "Generate action\n\nsource\n\ngenerate_action\n\n generate_action ()\n\ngenerate a pandas DataFrame for testing purpose"
  },
  {
    "objectID": "98_utils.html#generate-reward",
    "href": "98_utils.html#generate-reward",
    "title": "utils",
    "section": "Generate reward",
    "text": "Generate reward\n\nsource\n\ngenerate_reward\n\n generate_reward ()\n\ngenerate a pandas DataFrame for testing purpose"
  },
  {
    "objectID": "98_utils.html#generate-nstate",
    "href": "98_utils.html#generate-nstate",
    "title": "utils",
    "section": "Generate nstate",
    "text": "Generate nstate\n\nsource\n\ngenerate_nstate\n\n generate_nstate ()\n\ngenerate a pandas DataFrame for testing purpose"
  },
  {
    "objectID": "98_utils.html#generate-observation",
    "href": "98_utils.html#generate-observation",
    "title": "utils",
    "section": "Generate observation",
    "text": "Generate observation\n\nsource\n\ngenerate_observation\n\n generate_observation ()\n\ngenerate a list of pandas Series for testing purpose"
  },
  {
    "objectID": "98_utils.html#generate-multiindex-dataframe",
    "href": "98_utils.html#generate-multiindex-dataframe",
    "title": "utils",
    "section": "Generate MultiIndex DataFrame",
    "text": "Generate MultiIndex DataFrame\n\nsource\n\ngenerate_df_multiindex\n\n generate_df_multiindex ()"
  },
  {
    "objectID": "98_utils.html#prepend-two-levels-of-index-vehicle-and-driver-to-the-dataframe-object",
    "href": "98_utils.html#prepend-two-levels-of-index-vehicle-and-driver-to-the-dataframe-object",
    "title": "utils",
    "section": "prepend two levels of index “vehicle” and “driver” to the DataFrame object",
    "text": "prepend two levels of index “vehicle” and “driver” to the DataFrame object\n\nsource\n\ngenerate_eos_df\n\n generate_eos_df ()\n\ngenerate a pandas DataFrame for testing purpose\n\nassert isinstance(generate_eos_df().index, pd.MultiIndex), f\"dfs_episode.index is not a MultiIndex\"\n\n\nfrom fastcore.test import *\n\n\ntest_eq(isinstance(generate_eos_df().index, pd.MultiIndex), True)"
  }
]